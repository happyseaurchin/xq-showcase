<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4-Fold EM: Particle Field Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #000;
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        
        #canvas {
            display: block;
            cursor: grab;
        }
        
        .ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.92);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(136, 204, 255, 0.3);
            max-width: 300px;
            z-index: 100;
        }
        
        h1 {
            color: #88ccff;
            font-size: 1.1em;
            margin-bottom: 5px;
        }
        
        .subtitle {
            color: #888;
            font-size: 0.75em;
            margin-bottom: 15px;
        }
        
        .control-group {
            margin-bottom: 12px;
        }
        
        label {
            display: block;
            color: #88ccff;
            font-size: 0.8em;
            margin-bottom: 4px;
        }
        
        input[type="range"] {
            width: 100%;
            accent-color: #88ccff;
        }
        
        .value-display {
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            color: #ffd93d;
            text-align: right;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            font-size: 0.8em;
        }
        
        .checkbox-group input {
            width: 16px;
            height: 16px;
            accent-color: #88ccff;
        }
        
        .level-select {
            display: flex;
            gap: 6px;
            margin-top: 12px;
        }
        
        button {
            flex: 1;
            background: linear-gradient(135deg, #333 0%, #222 100%);
            color: white;
            border: 1px solid #555;
            padding: 8px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75em;
            transition: all 0.2s;
        }
        
        button:hover {
            background: linear-gradient(135deg, #444 0%, #333 100%);
        }
        
        button.active {
            background: linear-gradient(135deg, #4488cc 0%, #2266aa 100%);
            border-color: #88ccff;
        }
        
        .legend {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            padding: 12px;
            margin-top: 15px;
            font-size: 0.75em;
        }
        
        .legend-title {
            color: #88ccff;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 6px 0;
        }
        
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        
        .cascade-diagram {
            background: rgba(255, 200, 100, 0.1);
            border: 1px solid rgba(255, 200, 100, 0.3);
            border-radius: 6px;
            padding: 12px;
            margin-top: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            line-height: 1.8;
        }
        
        .cascade-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .cascade-arrow {
            color: #ffd93d;
        }
        
        .info-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.92);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(255, 107, 107, 0.4);
            font-size: 0.85em;
            max-width: 380px;
        }
        
        .info-panel h3 {
            color: #ff6b6b;
            margin-bottom: 10px;
        }
        
        .key-result {
            background: rgba(255, 107, 107, 0.15);
            border-left: 3px solid #ff6b6b;
            padding: 10px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="ui-overlay">
        <h1>EM Particle Field View</h1>
        <p class="subtitle">Current and B-field as flowing particles</p>
        
        <div class="control-group">
            <label>View Level</label>
            <div class="level-select">
                <button id="btnAll" class="active" onclick="setViewLevel('all')">All</button>
                <button id="btnL4" onclick="setViewLevel(4)">L4</button>
                <button id="btnL3" onclick="setViewLevel(3)">L3</button>
                <button id="btnL2" onclick="setViewLevel(2)">L2</button>
                <button id="btnL1" onclick="setViewLevel(1)">L1</button>
            </div>
        </div>
        
        <div class="control-group">
            <label>Particle density</label>
            <input type="range" id="densitySlider" min="20" max="200" step="10" value="80">
        </div>
        
        <div class="control-group">
            <label>Flow speed</label>
            <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1">
        </div>
        
        <div class="control-group">
            <label>Zoom</label>
            <input type="range" id="zoomSlider" min="0.3" max="4" step="0.1" value="1">
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="showCurrent" checked>
            <label for="showCurrent">Current particles (yellow)</label>
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="showBField" checked>
            <label for="showBField">B-field particles (cyan)</label>
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="showVectorField">
            <label for="showVectorField">Vector field arrows</label>
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="showStreamlines">
            <label for="showStreamlines">Streamlines</label>
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="showHeatmap">
            <label for="showHeatmap">Field intensity heatmap</label>
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="showStructure" checked>
            <label for="showStructure">Show torus structure</label>
        </div>
        
        <div class="checkbox-group">
            <input type="checkbox" id="autoRotate" checked>
            <label for="autoRotate">Auto-rotate</label>
        </div>
        
        <div class="legend">
            <div class="legend-title">Visualization Methods</div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #ffd93d; box-shadow: 0 0 6px #ffd93d;"></div>
                <span>Current particles (flow along wire)</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #00ffff; box-shadow: 0 0 6px #00ffff;"></div>
                <span>B-field particles (orbit wire)</span>
            </div>
            <div class="legend-item">
                <div style="width: 20px; height: 2px; background: #88f; position: relative;">
                    <div style="position: absolute; right: -4px; top: -3px; border-left: 6px solid #88f; border-top: 4px solid transparent; border-bottom: 4px solid transparent;"></div>
                </div>
                <span>Vector arrows (field direction)</span>
            </div>
            <div class="legend-item">
                <div style="width: 20px; height: 4px; background: linear-gradient(90deg, transparent, #0df); border-radius: 2px;"></div>
                <span>Streamlines (field flow)</span>
            </div>
            <div class="legend-item">
                <div style="width: 20px; height: 12px; background: linear-gradient(90deg, #009, #0ff, #0f0, #ff0, #f00); border-radius: 2px;"></div>
                <span>Heatmap (field intensity)</span>
            </div>
        </div>
        
        <div class="cascade-diagram">
            <div class="cascade-row">
                <span style="color:#ffd93d">I</span>
                <span class="cascade-arrow">→</span>
                <span style="color:#00ffff">B₁</span>
                <span class="cascade-arrow">→</span>
                <span style="color:#00cccc">B₂</span>
                <span class="cascade-arrow">→</span>
                <span style="color:#00aaaa">B₃</span>
                <span class="cascade-arrow">→</span>
                <span style="color:#ff6b6b">B₄</span>
            </div>
            <div style="text-align: center; margin-top: 5px; color: #ff6b6b;">
                B₄ ∥ I (4 × 90° = 360°)
            </div>
        </div>
    </div>
    
    <div class="info-panel">
        <h3>The 4-Fold Correspondence</h3>
        <p>Current flows through the spiral wire. At each level of coiling, the magnetic field rotates 90° relative to the current that generated it.</p>
        <div class="key-result">
            After 4 levels, the emergent B₄ field points in the <strong>same direction</strong> as the original current I — electromagnetic energy at the largest scale mirrors the smallest.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let zoom = 1;
        let rotationX = 0.4;
        let rotationY = 0;
        let autoRotate = true;
        let flowSpeed = 1;
        let particleDensity = 80;
        let showCurrent = true;
        let showBField = true;
        let showStructure = true;
        let showVectorField = false;
        let showStreamlines = false;
        let showHeatmap = false;
        let viewLevel = 'all';
        
        // Torus dimensions
        const levels = [
            { R: 3.0, r: 1.0, color: '#9b59b6', name: 'L4' },
            { R: 1.0, r: 0.33, color: '#4d96ff', name: 'L3' },
            { R: 0.33, r: 0.11, color: '#6bcb77', name: 'L2' },
            { R: 0.11, r: 0.037, color: '#ffd93d', name: 'L1' },
        ];
        
        // Particles
        let currentParticles = [];
        let bFieldParticles = [];
        let time = 0;
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();
        
        // Vector math
        function vec3(x, y, z) { return { x, y, z }; }
        function add(a, b) { return vec3(a.x + b.x, a.y + b.y, a.z + b.z); }
        function scale(v, s) { return vec3(v.x * s, v.y * s, v.z * s); }
        function normalize(v) {
            const len = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
            return len > 0 ? scale(v, 1/len) : v;
        }
        
        function rotateForView(p, rx, ry) {
            let { x, y, z } = p;
            let cos = Math.cos(rx), sin = Math.sin(rx);
            let y1 = y * cos - z * sin, z1 = y * sin + z * cos;
            y = y1; z = z1;
            cos = Math.cos(ry); sin = Math.sin(ry);
            let x1 = x * cos + z * sin;
            z1 = -x * sin + z * cos;
            return vec3(x1, y1, z1);
        }
        
        function project(point) {
            const p = rotateForView(point, rotationX, rotationY);
            const fov = 5;
            const scl = (canvas.height * 0.12 * zoom) / (fov + p.z * 0.15);
            return { x: canvas.width / 2 + p.x * scl, y: canvas.height / 2 - p.y * scl, z: p.z, scale: scl };
        }
        
        // Frame operations
        function createFrame(origin, e1, e2, e3) {
            return { origin, e1: normalize(e1), e2: normalize(e2), e3: normalize(e3) };
        }
        
        function localToWorld(localPt, frame) {
            return add(add(add(frame.origin, scale(frame.e1, localPt.x)), scale(frame.e2, localPt.y)), scale(frame.e3, localPt.z));
        }
        
        function identityFrame() {
            return createFrame(vec3(0, 0, 0), vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));
        }
        
        function getTorusTubeFrame(R, r, u, parentFrame) {
            const pathX = R * Math.cos(u);
            const pathY = R * Math.sin(u);
            const center = localToWorld(vec3(pathX, pathY, 0), parentFrame);
            
            const normalLocal = vec3(Math.cos(u), Math.sin(u), 0);
            const normal = normalize(add(add(scale(parentFrame.e1, normalLocal.x), scale(parentFrame.e2, normalLocal.y)), scale(parentFrame.e3, 0)));
            const binormal = parentFrame.e3;
            const tangentLocal = vec3(-Math.sin(u), Math.cos(u), 0);
            const tangent = normalize(add(add(scale(parentFrame.e1, tangentLocal.x), scale(parentFrame.e2, tangentLocal.y)), scale(parentFrame.e3, 0)));
            
            return createFrame(center, normal, binormal, tangent);
        }
        
        // Generate torus outline points
        function generateTorusOutline(R, r, frame, segments = 48) {
            const path = [];
            for (let i = 0; i <= segments; i++) {
                const u = (i / segments) * Math.PI * 2;
                const localPt = vec3(R * Math.cos(u), R * Math.sin(u), 0);
                path.push(localToWorld(localPt, frame));
            }
            return path;
        }
        
        // Generate tube circle at position u
        function generateTubeCircle(R, r, u, frame, segments = 24) {
            const tubeFrame = getTorusTubeFrame(R, r, u, frame);
            const circle = [];
            for (let i = 0; i <= segments; i++) {
                const v = (i / segments) * Math.PI * 2;
                const localPt = vec3(r * Math.cos(v), r * Math.sin(v), 0);
                circle.push(localToWorld(localPt, tubeFrame));
            }
            return circle;
        }
        
        // Initialize particles
        function initParticles() {
            currentParticles = [];
            bFieldParticles = [];
            
            const numCurrent = particleDensity;
            const numBField = Math.floor(particleDensity * 1.5);
            
            // Current particles - distributed along each level's path
            for (let i = 0; i < numCurrent; i++) {
                const levelIdx = Math.floor(Math.random() * 4);
                currentParticles.push({
                    level: levelIdx,
                    u: Math.random() * Math.PI * 2,
                    v: Math.random() * Math.PI * 2, // Position around tube
                    speed: 0.5 + Math.random() * 0.5
                });
            }
            
            // B-field particles - orbit around the wire at each level
            for (let i = 0; i < numBField; i++) {
                const levelIdx = Math.floor(Math.random() * 4);
                bFieldParticles.push({
                    level: levelIdx,
                    u: Math.random() * Math.PI * 2, // Position along torus
                    orbitAngle: Math.random() * Math.PI * 2, // Orbit phase
                    orbitRadius: 0.3 + Math.random() * 0.4, // How far from wire
                    speed: 0.8 + Math.random() * 0.4
                });
            }
        }
        
        // Get position for a current particle
        function getCurrentParticlePos(particle, t) {
            const frame4 = identityFrame();
            const L = levels[particle.level];
            
            let frame = frame4;
            // Navigate to the right level
            for (let i = 0; i < particle.level; i++) {
                frame = getTorusTubeFrame(levels[i].R, levels[i].r, t * 0.1 / (i + 1), frame);
            }
            
            const u = particle.u + t * particle.speed;
            const pathPt = vec3(
                (L.R + L.r * 0.5 * Math.cos(particle.v)) * Math.cos(u),
                (L.R + L.r * 0.5 * Math.cos(particle.v)) * Math.sin(u),
                L.r * 0.5 * Math.sin(particle.v)
            );
            
            return localToWorld(pathPt, frame);
        }
        
        // Get position for a B-field particle
        function getBFieldParticlePos(particle, t) {
            const frame4 = identityFrame();
            const L = levels[particle.level];
            
            let frame = frame4;
            for (let i = 0; i < particle.level; i++) {
                frame = getTorusTubeFrame(levels[i].R, levels[i].r, t * 0.1 / (i + 1), frame);
            }
            
            // Position along the torus path
            const u = particle.u + t * 0.1;
            const tubeFrame = getTorusTubeFrame(L.R, L.r, u, frame);
            
            // Orbit around the wire (B-field circulates)
            const orbitAngle = particle.orbitAngle + t * particle.speed * 2;
            const orbitR = L.r * particle.orbitRadius;
            
            const localPt = vec3(
                orbitR * Math.cos(orbitAngle),
                orbitR * Math.sin(orbitAngle),
                0
            );
            
            return localToWorld(localPt, tubeFrame);
        }
        
        // Draw a glowing particle
        function drawParticle(pos, color, size, glow = true) {
            const p = project(pos);
            const actualSize = size * p.scale * 0.015;
            
            // Parse color to RGB values
            let r, g, b;
            if (color.startsWith('#')) {
                r = parseInt(color.slice(1, 3), 16);
                g = parseInt(color.slice(3, 5), 16);
                b = parseInt(color.slice(5, 7), 16);
            } else if (color.startsWith('rgb')) {
                const match = color.match(/(\d+),\s*(\d+),\s*(\d+)/);
                if (match) {
                    r = parseInt(match[1]);
                    g = parseInt(match[2]);
                    b = parseInt(match[3]);
                }
            }
            
            if (glow && r !== undefined) {
                // Glow effect
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, actualSize * 3);
                gradient.addColorStop(0, `rgba(${r},${g},${b},1)`);
                gradient.addColorStop(0.3, `rgba(${r},${g},${b},0.5)`);
                gradient.addColorStop(1, `rgba(${r},${g},${b},0)`);
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, actualSize * 3, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
            }
            
            // Core
            ctx.beginPath();
            ctx.arc(p.x, p.y, actualSize, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        // Draw path
        function drawPath(points, color, width = 1, alpha = 1) {
            if (points.length < 2) return;
            ctx.beginPath();
            ctx.globalAlpha = alpha;
            const p0 = project(points[0]);
            ctx.moveTo(p0.x, p0.y);
            for (let i = 1; i < points.length; i++) {
                const p = project(points[i]);
                ctx.lineTo(p.x, p.y);
            }
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
        
        // Check if level should be shown
        function shouldShowLevel(levelIdx) {
            if (viewLevel === 'all') return true;
            return levelIdx === (4 - viewLevel); // levels array is reversed
        }
        
        // Calculate B-field direction at a point (simplified model)
        // B-field circles around current-carrying conductors
        function getBFieldAt(pos, frame, R, r) {
            // Find closest point on torus path
            const toCenter = vec3(pos.x - frame.origin.x, pos.y - frame.origin.y, pos.z - frame.origin.z);
            const dist = Math.sqrt(toCenter.x * toCenter.x + toCenter.y * toCenter.y + toCenter.z * toCenter.z);
            
            if (dist < 0.01) return vec3(0, 0, 0);
            
            // B-field is tangent to circles around the wire (right-hand rule)
            // Simplified: perpendicular to radial direction in the torus plane
            const radial = normalize(toCenter);
            
            // Cross with the "up" direction of the frame to get tangent
            const tangent = normalize(cross(frame.e3, radial));
            
            // Field strength falls off with distance
            const strength = 1 / (dist + 0.1);
            
            return scale(tangent, strength);
        }
        
        function cross(a, b) {
            return vec3(
                a.y * b.z - a.z * b.y,
                a.z * b.x - a.x * b.z,
                a.x * b.y - a.y * b.x
            );
        }
        
        // Draw vector field arrows on a grid
        function drawVectorField() {
            const frame4 = identityFrame();
            const gridSize = 12;
            const range = 4.5;
            const arrowScale = 0.25;
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const x = (i / (gridSize - 1) - 0.5) * range * 2;
                    const y = (j / (gridSize - 1) - 0.5) * range * 2;
                    const z = 0;
                    
                    const pos = vec3(x, y, z);
                    
                    // Calculate distance to torus center ring
                    const distToRing = Math.abs(Math.sqrt(x * x + y * y) - levels[0].R);
                    const distToTorus = Math.sqrt(distToRing * distToRing + z * z);
                    
                    // Only show arrows near the torus
                    if (distToTorus > levels[0].r * 2.5) continue;
                    
                    // Get B-field direction
                    const bField = getBFieldAt(pos, frame4, levels[0].R, levels[0].r);
                    const fieldStrength = Math.sqrt(bField.x * bField.x + bField.y * bField.y + bField.z * bField.z);
                    
                    if (fieldStrength < 0.1) continue;
                    
                    const arrowEnd = add(pos, scale(normalize(bField), arrowScale));
                    
                    // Color by field strength
                    const intensity = Math.min(1, fieldStrength * 2);
                    const r = Math.round(255 * intensity);
                    const g = Math.round(255 * (1 - intensity * 0.5));
                    const b = Math.round(255);
                    
                    drawArrow(pos, arrowEnd, `rgb(${r},${g},${b})`, 1.5);
                }
            }
        }
        
        // Draw an arrow
        function drawArrow(from, to, color, width) {
            const p1 = project(from);
            const p2 = project(to);
            
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();
            
            // Arrow head
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            const headLen = 5;
            ctx.beginPath();
            ctx.moveTo(p2.x, p2.y);
            ctx.lineTo(p2.x - headLen * Math.cos(angle - 0.4), p2.y - headLen * Math.sin(angle - 0.4));
            ctx.lineTo(p2.x - headLen * Math.cos(angle + 0.4), p2.y - headLen * Math.sin(angle + 0.4));
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        // Streamlines - traces that follow the field
        let streamlineParticles = [];
        let streamlinesInitialized = false;
        
        function initStreamlines() {
            streamlineParticles = [];
            const numStreamlines = 40;
            
            for (let i = 0; i < numStreamlines; i++) {
                // Start streamlines at various points around the torus
                const u = (i / numStreamlines) * Math.PI * 2;
                const R = levels[0].R;
                const r = levels[0].r;
                
                // Start just outside the torus tube
                const startR = R + r * 1.3;
                streamlineParticles.push({
                    pos: vec3(startR * Math.cos(u), startR * Math.sin(u), 0),
                    trail: [],
                    age: Math.random() * 100
                });
                
                // Start just inside
                const innerR = R - r * 1.3;
                if (innerR > 0) {
                    streamlineParticles.push({
                        pos: vec3(innerR * Math.cos(u), innerR * Math.sin(u), 0),
                        trail: [],
                        age: Math.random() * 100
                    });
                }
            }
            streamlinesInitialized = true;
        }
        
        function updateAndDrawStreamlines() {
            if (!streamlinesInitialized) initStreamlines();
            
            const frame4 = identityFrame();
            const dt = 0.03 * flowSpeed;
            const maxTrailLength = 30;
            
            for (const particle of streamlineParticles) {
                // Get field at current position
                const bField = getBFieldAt(particle.pos, frame4, levels[0].R, levels[0].r);
                const fieldStrength = Math.sqrt(bField.x * bField.x + bField.y * bField.y + bField.z * bField.z);
                
                // Move along field line
                if (fieldStrength > 0.01) {
                    const vel = scale(normalize(bField), dt * 0.5);
                    particle.pos = add(particle.pos, vel);
                }
                
                // Add to trail
                particle.trail.push({ ...particle.pos });
                if (particle.trail.length > maxTrailLength) {
                    particle.trail.shift();
                }
                
                particle.age += dt;
                
                // Reset if too far from torus
                const dist = Math.sqrt(particle.pos.x * particle.pos.x + particle.pos.y * particle.pos.y);
                if (dist > 6 || dist < 0.5 || particle.age > 150) {
                    const u = Math.random() * Math.PI * 2;
                    const R = levels[0].R;
                    const r = levels[0].r;
                    const startR = R + (Math.random() > 0.5 ? 1 : -1) * r * 1.3;
                    particle.pos = vec3(startR * Math.cos(u), startR * Math.sin(u), (Math.random() - 0.5) * r);
                    particle.trail = [];
                    particle.age = 0;
                }
                
                // Draw trail
                if (particle.trail.length > 1) {
                    ctx.beginPath();
                    const p0 = project(particle.trail[0]);
                    ctx.moveTo(p0.x, p0.y);
                    
                    for (let i = 1; i < particle.trail.length; i++) {
                        const p = project(particle.trail[i]);
                        ctx.lineTo(p.x, p.y);
                    }
                    
                    // Color fades along trail
                    const alpha = 0.7;
                    ctx.strokeStyle = `rgba(0, 220, 255, ${alpha})`;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    
                    // Draw head
                    const head = particle.trail[particle.trail.length - 1];
                    const pH = project(head);
                    ctx.beginPath();
                    ctx.arc(pH.x, pH.y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = '#00ffff';
                    ctx.fill();
                }
            }
        }
        
        // Heatmap - field intensity as color
        function drawHeatmap() {
            const frame4 = identityFrame();
            const resolution = 60;
            const range = 5;
            const cellSize = (range * 2) / resolution;
            
            // Pre-calculate field intensities
            const intensities = [];
            let maxIntensity = 0;
            
            for (let i = 0; i < resolution; i++) {
                intensities[i] = [];
                for (let j = 0; j < resolution; j++) {
                    const x = (i / resolution - 0.5) * range * 2;
                    const y = (j / resolution - 0.5) * range * 2;
                    const pos = vec3(x, y, 0);
                    
                    const bField = getBFieldAt(pos, frame4, levels[0].R, levels[0].r);
                    const intensity = Math.sqrt(bField.x * bField.x + bField.y * bField.y + bField.z * bField.z);
                    intensities[i][j] = intensity;
                    maxIntensity = Math.max(maxIntensity, intensity);
                }
            }
            
            // Draw heatmap cells
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const x = (i / resolution - 0.5) * range * 2;
                    const y = (j / resolution - 0.5) * range * 2;
                    
                    const intensity = intensities[i][j] / (maxIntensity + 0.01);
                    
                    if (intensity < 0.05) continue;
                    
                    // Color mapping: blue (low) -> cyan -> green -> yellow -> red (high)
                    let r, g, b;
                    if (intensity < 0.25) {
                        const t = intensity / 0.25;
                        r = 0; g = Math.round(100 * t); b = Math.round(150 + 50 * t);
                    } else if (intensity < 0.5) {
                        const t = (intensity - 0.25) / 0.25;
                        r = 0; g = Math.round(100 + 155 * t); b = Math.round(200 - 100 * t);
                    } else if (intensity < 0.75) {
                        const t = (intensity - 0.5) / 0.25;
                        r = Math.round(255 * t); g = 255; b = Math.round(100 - 100 * t);
                    } else {
                        const t = (intensity - 0.75) / 0.25;
                        r = 255; g = Math.round(255 - 155 * t); b = 0;
                    }
                    
                    const corners = [
                        vec3(x - cellSize/2, y - cellSize/2, 0),
                        vec3(x + cellSize/2, y - cellSize/2, 0),
                        vec3(x + cellSize/2, y + cellSize/2, 0),
                        vec3(x - cellSize/2, y + cellSize/2, 0)
                    ];
                    
                    const projCorners = corners.map(c => project(c));
                    
                    ctx.beginPath();
                    ctx.moveTo(projCorners[0].x, projCorners[0].y);
                    for (let k = 1; k < 4; k++) {
                        ctx.lineTo(projCorners[k].x, projCorners[k].y);
                    }
                    ctx.closePath();
                    ctx.fillStyle = `rgba(${r},${g},${b},${0.4 + intensity * 0.4})`;
                    ctx.fill();
                }
            }
            
            // Draw colorbar legend
            const barX = canvas.width - 40;
            const barY = canvas.height / 2 - 100;
            const barHeight = 200;
            const barWidth = 20;
            
            for (let i = 0; i < barHeight; i++) {
                const t = i / barHeight;
                let r, g, b;
                if (t < 0.25) {
                    const s = t / 0.25;
                    r = 0; g = Math.round(100 * s); b = Math.round(150 + 50 * s);
                } else if (t < 0.5) {
                    const s = (t - 0.25) / 0.25;
                    r = 0; g = Math.round(100 + 155 * s); b = Math.round(200 - 100 * s);
                } else if (t < 0.75) {
                    const s = (t - 0.5) / 0.25;
                    r = Math.round(255 * s); g = 255; b = Math.round(100 - 100 * s);
                } else {
                    const s = (t - 0.75) / 0.25;
                    r = 255; g = Math.round(255 - 155 * s); b = 0;
                }
                
                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(barX, barY + barHeight - i, barWidth, 1);
            }
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
            
            ctx.fillStyle = '#fff';
            ctx.font = '10px sans-serif';
            ctx.fillText('|B| max', barX - 5, barY - 5);
            ctx.fillText('0', barX + 5, barY + barHeight + 12);
        }
        
        // Main render
        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            time += flowSpeed * 0.02;
            
            const frame4 = identityFrame();
            
            // Draw heatmap first (background layer)
            if (showHeatmap) {
                drawHeatmap();
            }
            
            // Draw streamlines
            if (showStreamlines) {
                updateAndDrawStreamlines();
            }
            
            // Draw vector field
            if (showVectorField) {
                drawVectorField();
            }
            
            // Draw structure outlines
            if (showStructure) {
                // L4
                if (shouldShowLevel(0)) {
                    const path4 = generateTorusOutline(levels[0].R, levels[0].r, frame4);
                    drawPath(path4, levels[0].color, 1, 0.3);
                    
                    // Draw a few tube circles
                    for (let i = 0; i < 8; i++) {
                        const tube = generateTubeCircle(levels[0].R, levels[0].r, (i / 8) * Math.PI * 2, frame4);
                        drawPath(tube, levels[0].color, 0.5, 0.2);
                    }
                }
                
                // L3
                if (shouldShowLevel(1)) {
                    const frame3 = getTorusTubeFrame(levels[0].R, levels[0].r, 0, frame4);
                    const path3 = generateTorusOutline(levels[1].R, levels[1].r, frame3);
                    drawPath(path3, levels[1].color, 1, 0.4);
                    
                    for (let i = 0; i < 6; i++) {
                        const tube = generateTubeCircle(levels[1].R, levels[1].r, (i / 6) * Math.PI * 2, frame3);
                        drawPath(tube, levels[1].color, 0.5, 0.25);
                    }
                }
                
                // L2
                if (shouldShowLevel(2)) {
                    const frame3 = getTorusTubeFrame(levels[0].R, levels[0].r, 0, frame4);
                    const frame2 = getTorusTubeFrame(levels[1].R, levels[1].r, 0, frame3);
                    const path2 = generateTorusOutline(levels[2].R, levels[2].r, frame2);
                    drawPath(path2, levels[2].color, 1, 0.5);
                    
                    for (let i = 0; i < 6; i++) {
                        const tube = generateTubeCircle(levels[2].R, levels[2].r, (i / 6) * Math.PI * 2, frame2);
                        drawPath(tube, levels[2].color, 0.5, 0.3);
                    }
                }
                
                // L1
                if (shouldShowLevel(3)) {
                    const frame3 = getTorusTubeFrame(levels[0].R, levels[0].r, 0, frame4);
                    const frame2 = getTorusTubeFrame(levels[1].R, levels[1].r, 0, frame3);
                    const frame1 = getTorusTubeFrame(levels[2].R, levels[2].r, 0, frame2);
                    const path1 = generateTorusOutline(levels[3].R, levels[3].r, frame1);
                    drawPath(path1, levels[3].color, 1.5, 0.6);
                }
            }
            
            // Draw current particles
            if (showCurrent) {
                for (const particle of currentParticles) {
                    if (!shouldShowLevel(particle.level)) continue;
                    const pos = getCurrentParticlePos(particle, time);
                    const size = 4 - particle.level * 0.5;
                    drawParticle(pos, '#ffd93d', size, true);
                }
            }
            
            // Draw B-field particles
            if (showBField) {
                for (const particle of bFieldParticles) {
                    if (!shouldShowLevel(particle.level)) continue;
                    const pos = getBFieldParticlePos(particle, time);
                    const size = 3 - particle.level * 0.4;
                    
                    // Color varies by level - getting redder as we go outer (showing emergence)
                    let color;
                    if (particle.level === 0) {
                        color = '#ff6b6b'; // L4 B-field is red (aligned with I)
                    } else {
                        const t = particle.level / 3;
                        const r = Math.round(255 * (1 - t) + 0 * t);
                        const g = Math.round(107 * (1 - t) + 255 * t);
                        const b = Math.round(107 * (1 - t) + 255 * t);
                        color = `rgb(${r},${g},${b})`;
                    }
                    
                    drawParticle(pos, color, size, true);
                }
            }
            
            // Draw direction indicators
            if (viewLevel === 'all' || viewLevel === 4) {
                // I direction (original current)
                const iStart = project(vec3(-4.5, 0, 0));
                const iEnd = project(vec3(-3.8, 0, 0));
                
                ctx.beginPath();
                ctx.moveTo(iStart.x, iStart.y);
                ctx.lineTo(iEnd.x, iEnd.y);
                ctx.strokeStyle = '#ffd93d';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Arrow head
                ctx.beginPath();
                ctx.moveTo(iEnd.x, iEnd.y);
                ctx.lineTo(iEnd.x - 10, iEnd.y - 5);
                ctx.lineTo(iEnd.x - 10, iEnd.y + 5);
                ctx.closePath();
                ctx.fillStyle = '#ffd93d';
                ctx.fill();
                
                ctx.fillStyle = '#ffd93d';
                ctx.font = 'bold 16px sans-serif';
                ctx.fillText('I', iStart.x - 20, iStart.y + 5);
                
                // B4 direction (emergent field)
                const b4Start = project(vec3(3.8, 0, 0));
                const b4End = project(vec3(4.5, 0, 0));
                
                ctx.beginPath();
                ctx.moveTo(b4Start.x, b4Start.y);
                ctx.lineTo(b4End.x, b4End.y);
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(b4End.x, b4End.y);
                ctx.lineTo(b4End.x - 10, b4End.y - 5);
                ctx.lineTo(b4End.x - 10, b4End.y + 5);
                ctx.closePath();
                ctx.fillStyle = '#ff6b6b';
                ctx.fill();
                
                ctx.fillStyle = '#ff6b6b';
                ctx.font = 'bold 16px sans-serif';
                ctx.fillText('B₄', b4End.x + 10, b4End.y + 5);
                
                // Parallel symbol
                const midY = (iStart.y + b4Start.y) / 2 - 30;
                ctx.fillStyle = '#fff';
                ctx.font = '14px sans-serif';
                ctx.fillText('B₄ ∥ I', canvas.width / 2 - 20, 40);
            }
        }
        
        // Animation loop
        function animate() {
            if (autoRotate) {
                rotationY += 0.004;
            }
            
            render();
            requestAnimationFrame(animate);
        }
        
        function setViewLevel(level) {
            viewLevel = level;
            document.querySelectorAll('.level-select button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(level === 'all' ? 'btnAll' : 'btnL' + level).classList.add('active');
            
            // Adjust zoom for level
            if (level === 'all') zoom = 1;
            else if (level === 4) zoom = 0.8;
            else if (level === 3) zoom = 2;
            else if (level === 2) zoom = 4;
            else if (level === 1) zoom = 10;
            
            document.getElementById('zoomSlider').value = zoom;
        }
        window.setViewLevel = setViewLevel;
        
        // Event listeners
        document.getElementById('densitySlider').addEventListener('input', (e) => {
            particleDensity = parseInt(e.target.value);
            initParticles();
        });
        
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            flowSpeed = parseFloat(e.target.value);
        });
        
        document.getElementById('zoomSlider').addEventListener('input', (e) => {
            zoom = parseFloat(e.target.value);
        });
        
        document.getElementById('showCurrent').addEventListener('change', (e) => {
            showCurrent = e.target.checked;
        });
        
        document.getElementById('showBField').addEventListener('change', (e) => {
            showBField = e.target.checked;
        });
        
        document.getElementById('showStructure').addEventListener('change', (e) => {
            showStructure = e.target.checked;
        });
        
        document.getElementById('showVectorField').addEventListener('change', (e) => {
            showVectorField = e.target.checked;
        });
        
        document.getElementById('showStreamlines').addEventListener('change', (e) => {
            showStreamlines = e.target.checked;
            if (e.target.checked) initStreamlines();
        });
        
        document.getElementById('showHeatmap').addEventListener('change', (e) => {
            showHeatmap = e.target.checked;
        });
        
        document.getElementById('autoRotate').addEventListener('change', (e) => {
            autoRotate = e.target.checked;
        });
        
        // Mouse controls
        let isDragging = false;
        let lastX, lastY;
        
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                rotationY += (e.clientX - lastX) * 0.005;
                rotationX += (e.clientY - lastY) * 0.005;
                lastX = e.clientX;
                lastY = e.clientY;
            }
        });
        
        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            zoom *= e.deltaY > 0 ? 0.95 : 1.05;
            zoom = Math.max(0.3, Math.min(15, zoom));
            document.getElementById('zoomSlider').value = zoom;
        });
        
        // Initialize and start
        initParticles();
        animate();
    </script>
</body>
</html>
